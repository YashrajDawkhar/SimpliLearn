import { __decorate, __metadata, __param } from "tslib";
import { Injectable, NgZone, Optional } from '@angular/core';
import { PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { LoadingBarState } from './loading-bar.state';
import { Subject, combineLatest, Observable } from 'rxjs';
import { switchMap, map, startWith } from 'rxjs/operators';
import { LOADING_BAR_CONFIG } from './loading-bar.config';
import * as i0 from "@angular/core";
import * as i1 from "./loading-bar.config";
import * as ɵngcc0 from '@angular/core';
let LoadingBarService = class LoadingBarService {
    constructor(platformId, config = {}, zone) {
        this.platformId = platformId;
        this.config = config;
        this.zone = zone;
        this.refs = {};
        this.streams$ = new Subject();
        this.value$ = this.streams$.asObservable().pipe(startWith(null), switchMap(() => combineLatest(...Object.keys(this.refs).map((s) => this.refs[s].value$))), runInZone(this.zone), map((v) => Math.max(0, ...v)));
    }
    /** @deprecated use `value$` instead. */
    get progress$() {
        return this.value$;
    }
    /** @deprecated use `useRef` instead. */
    start(initialValue = 2) {
        this.useRef().start(initialValue);
    }
    /** @deprecated use `useRef` instead. */
    set(value) {
        this.useRef().set(value);
    }
    /** @deprecated use `useRef` instead. */
    increment(value) {
        this.useRef().increment(value);
    }
    /** @deprecated use `useRef` instead. */
    complete() {
        this.useRef().complete();
    }
    /** @deprecated use `useRef` instead. */
    stop() {
        this.useRef().stop();
    }
    useRef(id = 'default') {
        if (!this.refs[id]) {
            this.refs[id] = new LoadingBarState(this.config);
            this.streams$.next();
            if (!isPlatformBrowser(this.platformId)) {
                this.refs[id].disable();
            }
        }
        return this.refs[id];
    }
};
LoadingBarService.ɵfac = function LoadingBarService_Factory(t) { return new (t || LoadingBarService)(ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(LOADING_BAR_CONFIG, 8), ɵngcc0.ɵɵinject(ɵngcc0.NgZone, 8)); };
LoadingBarService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOADING_BAR_CONFIG,] }] },
    { type: NgZone, decorators: [{ type: Optional }] }
];
LoadingBarService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LoadingBarService_Factory() { return new LoadingBarService(i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i1.LOADING_BAR_CONFIG, 8), i0.ɵɵinject(i0.NgZone, 8)); }, token: LoadingBarService, providedIn: "root" });
LoadingBarService = __decorate([ __param(0, Inject(PLATFORM_ID)),
    __param(1, Optional()), __param(1, Inject(LOADING_BAR_CONFIG)),
    __param(2, Optional()),
    __metadata("design:paramtypes", [Object, Object, NgZone])
], LoadingBarService);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingBarService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LOADING_BAR_CONFIG]
            }] }, { type: ɵngcc0.NgZone, decorators: [{
                type: Optional
            }] }]; }, null); })();
export { LoadingBarService };
// https://stackoverflow.com/a/57452361/1406096
export function runInZone(zone) {
    if (!zone) {
        return (source) => source;
    }
    return (source) => new Observable((observer) => source.subscribe((value) => zone.run(() => observer.next(value)), (e) => zone.run(() => observer.error(e)), () => zone.run(() => observer.complete())));
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGluZy1iYXIuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiQG5neC1sb2FkaW5nLWJhci9jb3JlL2xvYWRpbmctYmFyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsVUFBVSxFQUFvQixNQUFNLE1BQU0sQ0FBQztBQUM1RSxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsa0JBQWtCLEVBQW9CLE1BQU0sc0JBQXNCLENBQUM7QUFDNUU7QUFFQTs7QUFBQSxJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFpQjtBQUM5QixJQWNFLFlBQytCLFVBQWtCLEVBQ0MsU0FBMkIsRUFBRSxFQUN6RCxJQUFhO0FBQ25DLFFBSCtCLGVBQVUsR0FBVixVQUFVLENBQVE7QUFBQyxRQUNBLFdBQU0sR0FBTixNQUFNLENBQXVCO0FBQUMsUUFDMUQsU0FBSSxHQUFKLElBQUksQ0FBUztBQUFDLFFBakI1QixTQUFJLEdBQXNDLEVBQUUsQ0FBQztBQUN2RCxRQUFVLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0FBQ3pDLFFBQVcsV0FBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUNqRCxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQ2YsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxHQUFHLE1BQU0s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RDlCLCtDQUErQztBQUMvQyxNQUFNLFVBQVUsU0FBUyxDQUFJLElBQVk7QUFBSSxJQUMzQyxJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ2IsUUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUM7QUFDOUIsS0FBRztBQUNILElBQ0UsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ2hCLElBQUksVUFBVSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FDMUIsTUFBTSxDQUFDLFNBQVMsQ0FDZCxDQUFDLEtBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQ2xELENBQUMsQ0FBTSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDN0MsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDMUMsQ0FDRixDQUFDO0FBQ04sQ0FBQztBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTG9hZGluZ0JhclN0YXRlIH0gZnJvbSAnLi9sb2FkaW5nLWJhci5zdGF0ZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlLCBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAsIG1hcCwgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTE9BRElOR19CQVJfQ09ORklHLCBMb2FkaW5nQmFyQ29uZmlnIH0gZnJvbSAnLi9sb2FkaW5nLWJhci5jb25maWcnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIExvYWRpbmdCYXJTZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWZzOiB7IFtpZDogc3RyaW5nXTogTG9hZGluZ0JhclN0YXRlIH0gPSB7fTtcbiAgcHJpdmF0ZSBzdHJlYW1zJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHJlYWRvbmx5IHZhbHVlJCA9IHRoaXMuc3RyZWFtcyQuYXNPYnNlcnZhYmxlKCkucGlwZShcbiAgICBzdGFydFdpdGgobnVsbCksXG4gICAgc3dpdGNoTWFwKCgpID0+IGNvbWJpbmVMYXRlc3QoLi4uT2JqZWN0LmtleXModGhpcy5yZWZzKS5tYXAoKHMpID0+IHRoaXMucmVmc1tzXS52YWx1ZSQpKSksXG4gICAgcnVuSW5ab25lKHRoaXMuem9uZSksXG4gICAgbWFwKCh2KSA9PiBNYXRoLm1heCgwLCAuLi52KSksXG4gICk7XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdmFsdWUkYCBpbnN0ZWFkLiAqL1xuICBnZXQgcHJvZ3Jlc3MkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlJDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTE9BRElOR19CQVJfQ09ORklHKSBwcml2YXRlIGNvbmZpZzogTG9hZGluZ0JhckNvbmZpZyA9IHt9LFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgem9uZT86IE5nWm9uZSxcbiAgKSB7fVxuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHVzZVJlZmAgaW5zdGVhZC4gKi9cbiAgc3RhcnQoaW5pdGlhbFZhbHVlID0gMikge1xuICAgIHRoaXMudXNlUmVmKCkuc3RhcnQoaW5pdGlhbFZhbHVlKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHVzZVJlZmAgaW5zdGVhZC4gKi9cbiAgc2V0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLnVzZVJlZigpLnNldCh2YWx1ZSk7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB1c2VSZWZgIGluc3RlYWQuICovXG4gIGluY3JlbWVudCh2YWx1ZT86IG51bWJlcikge1xuICAgIHRoaXMudXNlUmVmKCkuaW5jcmVtZW50KHZhbHVlKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHVzZVJlZmAgaW5zdGVhZC4gKi9cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy51c2VSZWYoKS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdXNlUmVmYCBpbnN0ZWFkLiAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMudXNlUmVmKCkuc3RvcCgpO1xuICB9XG5cbiAgdXNlUmVmKGlkOiBzdHJpbmcgPSAnZGVmYXVsdCcpOiBMb2FkaW5nQmFyU3RhdGUge1xuICAgIGlmICghdGhpcy5yZWZzW2lkXSkge1xuICAgICAgdGhpcy5yZWZzW2lkXSA9IG5ldyBMb2FkaW5nQmFyU3RhdGUodGhpcy5jb25maWcpO1xuICAgICAgdGhpcy5zdHJlYW1zJC5uZXh0KCk7XG5cbiAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICB0aGlzLnJlZnNbaWRdLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWZzW2lkXTtcbiAgfVxufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTc0NTIzNjEvMTQwNjA5NlxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkluWm9uZTxUPih6b25lOiBOZ1pvbmUpOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQ+IHtcbiAgaWYgKCF6b25lKSB7XG4gICAgcmV0dXJuIChzb3VyY2UpID0+IHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiAoc291cmNlKSA9PlxuICAgIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT5cbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgICh2YWx1ZTogVCkgPT4gem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dCh2YWx1ZSkpLFxuICAgICAgICAoZTogYW55KSA9PiB6b25lLnJ1bigoKSA9PiBvYnNlcnZlci5lcnJvcihlKSksXG4gICAgICAgICgpID0+IHpvbmUucnVuKCgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCkpLFxuICAgICAgKSxcbiAgICApO1xufVxuIl19